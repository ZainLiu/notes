### Linux相关

+ ##### struct cgroup_subsys_state __rcu *subsys[CGROUP_SUBSYS_COUNT];这样定义结构体，里面的参数分别代表什么 

  ```
  这条语句定义了一个包含 CGROUP_SUBSYS_COUNT 个指向 struct cgroup_subsys_state 类型的、被修饰为 __rcu 的指针数组 subsys。具体解释如下：
  
  struct cgroup_subsys_state 是一个结构体类型，用来表示一个控制组子系统的状态信息。__rcu 是一种 Linux 内核中的机制，用于实现“可读复制更新”（Read-Copy Update）的数据访问方式，以解决并发更新共享数据时的一些问题。
  
  subsys 是一个指针数组，用来存储指向 struct cgroup_subsys_state 类型的指针。CGROUP_SUBSYS_COUNT 是一个常量，表示控制组子系统的数量，通常是一个预定义的值。这个数组中的每个元素都指向一个控制组子系统的状态信息。
  
  综合起来，这条语句定义了一个包含多个控制组子系统状态信息的数组，数组的每个元素都是一个指向 struct cgroup_subsys_state 类型的指针，并使用 __rcu 修饰以支持并发更新。
  ```

  

+ #####  什么是可读复制更新”（Read-Copy Update） 

  ```
  "可读复制更新"（Read-Copy Update，简称RCU）是一种用于多线程环境下读取共享数据的技术，在 Linux 内核等操作系统中得到广泛应用。
  
  在传统的读写锁或者互斥锁中，每次读取共享数据都需要获取锁，这会导致频繁的锁竞争和上下文切换，降低系统性能。而 RCU 技术则提供了一种无锁的读取共享数据的方式，避免了锁竞争和上下文切换，从而提高了系统的并发性和性能。
  
  RCU 的实现原理是：在更新共享数据时，不直接修改原始数据，而是复制一份副本，并在副本上进行更新，同时在原始数据和副本之间建立一个映射关系。这样，读取共享数据时，可以直接访问原始数据，不会被修改影响；而更新共享数据时，可以通过修改副本并更新映射关系来实现，不需要获取锁。
  
  RCU 技术相比传统的锁机制，可以提高并发度和吞吐量，适用于读多写少的场景。但也有一些缺点，如增加了内存占用、对实现要求较高等。
  ```

+ #####  什么是__percpu 

  ```
  __percpu 是 Linux 内核中的一种机制，用于在多核系统中实现高效的数据访问和内存分配。它是一种 GCC 的扩展特性，用于将变量声明为“按 CPU 分配”的变量，也就是说，每个 CPU 上都会有一份该变量的拷贝，从而避免了多个 CPU 之间的竞争和同步。
  
  在内核中，使用 __percpu 声明的变量被称为“per-CPU 变量”，可以通过特定的宏来访问，例如 this_cpu_read() 和 this_cpu_write()。这些宏可以自动根据当前 CPU 的编号访问相应的变量，从而实现高效的数据访问和内存分配。
  
  使用 __percpu 可以避免多个 CPU 之间的竞争和同步，提高系统的并发性和性能。但也需要注意一些问题，如内存分配的效率、变量的对齐和访问等问题。因此，使用 __percpu 需要谨慎，并根据实际情况进行选择和优化。
  ```

  