### Linux相关

+ ##### struct cgroup_subsys_state __rcu *subsys[CGROUP_SUBSYS_COUNT];这样定义结构体，里面的参数分别代表什么 

  ```
  这条语句定义了一个包含 CGROUP_SUBSYS_COUNT 个指向 struct cgroup_subsys_state 类型的、被修饰为 __rcu 的指针数组 subsys。具体解释如下：
  
  struct cgroup_subsys_state 是一个结构体类型，用来表示一个控制组子系统的状态信息。__rcu 是一种 Linux 内核中的机制，用于实现“可读复制更新”（Read-Copy Update）的数据访问方式，以解决并发更新共享数据时的一些问题。
  
  subsys 是一个指针数组，用来存储指向 struct cgroup_subsys_state 类型的指针。CGROUP_SUBSYS_COUNT 是一个常量，表示控制组子系统的数量，通常是一个预定义的值。这个数组中的每个元素都指向一个控制组子系统的状态信息。
  
  综合起来，这条语句定义了一个包含多个控制组子系统状态信息的数组，数组的每个元素都是一个指向 struct cgroup_subsys_state 类型的指针，并使用 __rcu 修饰以支持并发更新。
  ```

  

+ #####  什么是可读复制更新”（Read-Copy Update） 

  ```
  "可读复制更新"（Read-Copy Update，简称RCU）是一种用于多线程环境下读取共享数据的技术，在 Linux 内核等操作系统中得到广泛应用。
  
  在传统的读写锁或者互斥锁中，每次读取共享数据都需要获取锁，这会导致频繁的锁竞争和上下文切换，降低系统性能。而 RCU 技术则提供了一种无锁的读取共享数据的方式，避免了锁竞争和上下文切换，从而提高了系统的并发性和性能。
  
  RCU 的实现原理是：在更新共享数据时，不直接修改原始数据，而是复制一份副本，并在副本上进行更新，同时在原始数据和副本之间建立一个映射关系。这样，读取共享数据时，可以直接访问原始数据，不会被修改影响；而更新共享数据时，可以通过修改副本并更新映射关系来实现，不需要获取锁。
  
  RCU 技术相比传统的锁机制，可以提高并发度和吞吐量，适用于读多写少的场景。但也有一些缺点，如增加了内存占用、对实现要求较高等。
  ```

+ #####  什么是__percpu 

  ```
  __percpu 是 Linux 内核中的一种机制，用于在多核系统中实现高效的数据访问和内存分配。它是一种 GCC 的扩展特性，用于将变量声明为“按 CPU 分配”的变量，也就是说，每个 CPU 上都会有一份该变量的拷贝，从而避免了多个 CPU 之间的竞争和同步。
  
  在内核中，使用 __percpu 声明的变量被称为“per-CPU 变量”，可以通过特定的宏来访问，例如 this_cpu_read() 和 this_cpu_write()。这些宏可以自动根据当前 CPU 的编号访问相应的变量，从而实现高效的数据访问和内存分配。
  
  使用 __percpu 可以避免多个 CPU 之间的竞争和同步，提高系统的并发性和性能。但也需要注意一些问题，如内存分配的效率、变量的对齐和访问等问题。因此，使用 __percpu 需要谨慎，并根据实际情况进行选择和优化。
  ```

+ #####  可以详细的描述一下python的asynicio是如何进行协程间的切换的 

  ```
  在Python的asyncio中，协程切换是通过一个叫做“事件循环”（Event Loop）的机制来实现的。
  
  在使用asyncio编写代码时，会先创建一个事件循环对象，然后将协程注册到事件循环中。当一个协程遇到I/O操作时，它会暂停并将控制权返回给事件循环。事件循环会继续运行并执行其他已经注册的协程，直到有一个协程需要等待I/O操作完成。
  
  当一个I/O操作完成时，事件循环会检查等待该I/O操作的协程，然后重新唤醒该协程，使其继续执行。这个过程中，事件循环会进行协程间的切换，以便让不同的协程在适当的时候获得执行的机会。
  
  实际上，事件循环会不断地轮询已经注册的协程，如果某个协程已经完成了等待的I/O操作，那么事件循环会将其加入一个“就绪队列”（Ready Queue）中，等待下一次的调度。当事件循环轮到这个协程时，它会将其唤醒并继续执行。
  
  总之，asyncio的协程切换是通过事件循环机制实现的，通过轮询已注册的协程以及将就绪的协程加入到一个队列中，以实现协程之间的切换。
  ```

+ #####  一个event loop就是一个线程吗 

  ```
  在Python的asyncio中，一个事件循环通常是运行在一个单独的线程中。这个线程负责管理协程的调度，以及处理I/O操作等事件。在事件循环内部，协程是按顺序依次执行的，因此它们之间不需要进行线程同步等复杂的操作。由于Python的GIL限制了多线程并发执行，因此单线程中的协程调度是一个相对高效的解决方案。
  
  需要注意的是，尽管事件循环本身运行在单独的线程中，但是在协程内部仍然可以使用阻塞式的I/O操作，例如调用socket的recv方法等。这些I/O操作实际上是在操作系统底层的系统调用中被执行的，因此会阻塞整个线程。为了避免这种情况，asyncio提供了一些异步的I/O操作接口，例如asyncio.open_connection()、asyncio.start_server()等，它们底层使用了操作系统的异步I/O机制，从而避免了线程的阻塞。
  ```

+ #####  tornado有使用asynicio吗 

  ```
  Tornado是一种基于Python的Web框架，它采用异步I/O的方式处理请求。与asyncio相比，Tornado采用了自己的事件循环实现异步I/O操作，而没有直接使用Python标准库中的asyncio库。
  
  Tornado的事件循环实现了与asyncio类似的协程切换机制，通过在I/O操作等待时挂起协程并切换到下一个就绪的协程，从而实现了高效的异步I/O操作。
  
  虽然Tornado没有直接使用asyncio库，但它也提供了类似于asyncio中的异步I/O操作接口，例如tornado.gen.coroutine、tornado.ioloop.IOLoop.current()等，可以方便地编写异步的网络应用程序。另外，Tornado也支持使用协程来编写异步的HTTP客户端和服务器，这与asyncio的用法类似。
  
  总之，尽管Tornado没有直接使用asyncio库，但它也提供了类似于asyncio中的异步I/O操作接口，并采用了协程切换机制来实现高效的异步I/O操作。
  ```

+ #####  CPU每执行一条指令，该指令就会从PC寄存器删除吗 

  ```
  在大多数现代计算机架构中，CPU的指令执行过程是按照程序的指令流程逐条执行的，也就是说，每执行一条指令，PC寄存器（程序计数器）都会自动加上当前指令的长度，指向下一条指令的地址。
  
  PC寄存器是一种特殊的寄存器，用来存储当前程序的执行位置，也就是下一条将要执行的指令的地址。当CPU开始执行程序时，PC寄存器被初始化为程序的入口地址。然后，CPU开始按照指令流程逐条执行指令，并自动更新PC寄存器的值，使其指向下一条将要执行的指令的地址。这个过程一直持续到程序结束或者遇到某个跳转指令（例如JMP、CALL等），这时CPU会跳转到指定的地址，并更新PC寄存器的值，使其指向跳转目标地址。
  
  因此，在CPU执行指令的过程中，每执行一条指令，PC寄存器都会自动更新为下一条指令的地址，而不是删除当前指令。
  ```

+ #####  为什么在windows下装了docker会出现一个linux文件夹 

  ```
  当在 Windows 操作系统上安装 Docker 后，Docker 就会在计算机上运行一个轻量级的虚拟机（Linux Kit）作为 Docker 环境。这个虚拟机运行的是 Linux 内核，并提供了 Docker 运行环境。因此，当你在 Windows 上使用 Docker 时，你会看到一个名为“Linux”的文件夹，它包含了在 Docker 虚拟机上运行的容器和镜像等文件。这个文件夹允许你在 Windows 和 Linux 系统之间共享文件和数据，也方便了在 Docker 容器之间共享数据的操作。
  ```

  